# -*- coding: utf-8 -*-
"""objectdetect_3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hRJlCDvDuMALCEa2_PLdJ4BU5yyAdzG_

เเหล่งที่มา https://github.com/ultralytics/yolov5
"""

!apt list --upgradable

!pip install scikit-learn matplotlib

"""map results"""

import matplotlib.pyplot as plt

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix

# Commented out IPython magic to ensure Python compatibility.
!git clone https://github.com/ultralytics/yolov5  # clone
# %cd /content/yolov5
# %pip install -qr requirements.txt comet_ml  # install

import torch
import utils
display = utils.notebook_init()  # checks

!python train.py --img 640 --batch 16 --epochs 3 --data coco128.yaml --weights yolov5s.pt --cache

y_true = [2, 0, 2, 2, 0, 1]
y_pred = [0, 0, 2, 2, 0, 2]
cm = confusion_matrix(y_true, y_pred)

plt.imshow(cm, interpolation='nearest', cmap=plt.cm.Blues)
plt.title('Confusion Matrix')
plt.colorbar()

plt.xlabel('Predicted Label')
plt.ylabel('True Label')

plt.show()

# สมมติว่าค่า MAP results มีอยู่ในตัวแปร map_results ในรูปแบบของลิสต์หรืออาเรย์
map_results = [0.85, 0.92, 0.78, 0.95, 0.88]

# แสดงกราฟเส้น
plt.plot(map_results)
plt.title('MAP Results')
plt.xlabel('Iteration')
plt.ylabel('MAP')
plt.show()

# หรือแสดงกราฟแท่ง
plt.bar(range(len(map_results)), map_results)
plt.title('MAP Results')
plt.xlabel('Iteration')
plt.ylabel('MAP')
plt.show()

def accuracy(y_true, y_pred):
    """
    คำนวณค่าความแม่นยำ
    :param y_true: ค่าจริง
    :param y_pred: ค่าทำนาย
    :return: ค่าความแม่นยำ
    """
    correct = 0
    total = len(y_true)

    for true, pred in zip(y_true, y_pred):
        if true == pred:
            correct += 1

    return correct / total

# ตัวอย่างการใช้งาน
y_true = [0, 1, 0, 1, 1]
y_pred = [0, 1, 0, 0, 1]

print("Accuracy:", accuracy(y_true, y_pred))

display.Image(filename='/content/yolov5/runs/train/exp/confusion_matrix.png', width=600)

!python detect.py --weights yolov5x.pt --img 640 --conf 0.25 --source test/

display.Image(filename='runs/detect/exp2/001.png', width=300)

display.Image(filename='runs/detect/exp2/002.PNG', width=300)

display.Image(filename='runs/detect/exp2/003.PNG', width=300)

display.Image(filename='runs/detect/exp2/004.PNG', width=300)

display.Image(filename='runs/detect/exp2/005.PNG', width=300)

display.Image(filename='runs/detect/exp2/006.PNG', width=300)

display.Image(filename='runs/detect/exp2/007.PNG', width=300)

display.Image(filename='runs/detect/exp2/008.PNG', width=300)

display.Image(filename='runs/detect/exp2/009.PNG', width=300)

display.Image(filename='runs/detect/exp2/010.PNG', width=300)

display.Image(filename='runs/detect/exp2/011.PNG', width=300)

display.Image(filename='runs/detect/exp2/012.PNG', width=300)

display.Image(filename='runs/detect/exp2/013.PNG', width=300)

display.Image(filename='runs/detect/exp2/014.PNG', width=300)

display.Image(filename='runs/detect/exp2/015.PNG', width=300)

#รูปที่ถ่ายมาเอง
display.Image(filename='runs/detect/exp/018.jpg', width=300)

#รูปที่ถ่ายมาเอง
display.Image(filename='runs/detect/exp/019.jpg', width=300)

#รูปที่ถ่ายมาเอง
display.Image(filename='runs/detect/exp/021.jpg', width=300)

#รูปที่ถ่ายมาเอง
display.Image(filename='runs/detect/exp2/024.jpg', width=300)

#รูปที่ถ่ายมาเอง
display.Image(filename='runs/detect/exp2/026.jpg', width=300)

#รูปที่ถ่ายมาเอง
display.Image(filename='runs/detect/exp2/027.jpg', width=300)

#รูปที่ถ่ายมาเอง
display.Image(filename='runs/detect/exp3/028.jpg', width=300)

!pip install opencv-python-headless
!apt-get install -y ffmpeg

#เเสดงวีดีโอเมื่อdetectเป็นเฟรมในรูปเเบบรูปภาพ
import cv2
from google.colab.patches import cv2_imshow

# Specify the path to your video file
video_path = '/content/yolov5/runs/detect/exp2/video2.mp4'

# Open the video file
video = cv2.VideoCapture(video_path)

# Read and display frames
while video.isOpened():
    ret, frame = video.read()
    if not ret:
        break
    cv2_imshow(frame)  # Display the frame

video.release()
cv2.destroyAllWindows()

#เเสดงวีดีโอเมื่อdetectเป็นเฟรมในรูปเเบบวีดีโอ
import imageio
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from skimage.transform import resize
from IPython.display import HTML

def display_video(video_frames):
    fig = plt.figure(figsize=(7,7))  # Specify display size

    mov = []
    for frame in video_frames:  # Append frames one by one to mov
        img = plt.imshow(frame, animated=True)
        plt.axis('off')
        mov.append([img])

    # Create animation
    anime = animation.ArtistAnimation(fig, mov, interval=50, repeat_delay=1000)

    plt.close()
    return anime

# Load video frames one by one instead of using imageio.mimread()
video_frames = []
reader = imageio.get_reader('/content/yolov5/runs/detect/exp/video2.mp4')
for frame in reader:
    video_frames.append(resize(frame, (256, 256))[..., :3])  # Resize frames if necessary

HTML(display_video(video_frames).to_html5_video())  # Inline video display in HTML5

#ถ่ายคลิปเอง
#เเสดงวีดีโอเมื่อdetectเป็นเฟรมในรูปเเบบรูปภาพ
import cv2
from google.colab.patches import cv2_imshow

# Specify the path to your video file
video_path = '/content/yolov5/runs/detect/exp2/video3.mp4'

# Open the video file
video = cv2.VideoCapture(video_path)

# Read and display frames
while video.isOpened():
    ret, frame = video.read()
    if not ret:
        break
    cv2_imshow(frame)  # Display the frame

video.release()
cv2.destroyAllWindows()

#ถ่ายคลิปเอง
#เเสดงวีดีโอเมื่อdetectเป็นเฟรมในรูปเเบบวีดีโอ
import imageio
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from skimage.transform import resize
from IPython.display import HTML

def display_video(video_frames):
    fig = plt.figure(figsize=(7,7))  # Specify display size

    mov = []
    for frame in video_frames:  # Append frames one by one to mov
        img = plt.imshow(frame, animated=True)
        plt.axis('off')
        mov.append([img])

    # Create animation
    anime = animation.ArtistAnimation(fig, mov, interval=50, repeat_delay=1000)

    plt.close()
    return anime

# Load video frames one by one instead of using imageio.mimread()
video_frames = []
reader = imageio.get_reader('/content/yolov5/runs/detect/exp2/video3.mp4')
for frame in reader:
    video_frames.append(resize(frame, (256, 256))[..., :3])  # Resize frames if necessary

HTML(display_video(video_frames).to_html5_video())  # Inline video display in HTML5